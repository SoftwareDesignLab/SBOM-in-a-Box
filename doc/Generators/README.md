# Generators
> System that collects information from both source and package manager files and generates an SBOM, to be outputted
to either the CycloneDX or SPDX schema, and the XML, JSON, or YAML format.

# Last Changelog Update

## [v4.4.2-alpha] - (05/18/2023)

This update focuses mainly on adding several test cases for most generator classes and fixing bugs in the stores,
serializers, and translators.

### Added
- Added tests for `SBOMGenerator.writeFileToString()` in `SBOMGeneratorTest`.
    - These test for cases where pretty-printing is enabled and disabled.
- Added a mostly complete suite of test cases for all non-dataclasses in the `sbomfactory.generators.generators` package.
    - `BOMStoreTestCore` - An abstract test class to setup an SBOM and test component behavior for all classes that extend `BOMStore`.
    - `CycloneDXStoreTest` - Tests all CycloneDX BOM manipulation methods
    - `SPDXStoreTest` - Tests all SPDX Document manipulation methods
- Added test cases for all custom serializer classes in the `sbomfactory.generators.generators` package.
    - For each class, a generator serializes a test SBOM object to a file. Then, the SVIP translators are used to translate
      the SBOM file back into an SBOM object. The two are then checked to ensure equality, and if so the test passes. This
      allows us to ensure that an SBOM can go both ways, via the generators and translators.
        - `CycloneDXSerializerTest`
        - `CycloneDXXMLSerializerTest`
        - `SPDXTagValueWriterTest`
    - Note that because there are no translators for SPDX JSON and XML formats (yet), we cannot test the outputs of those
      corresponding serializers.
- Added **INTERNAL** SBOM comparison methods:
    - `SBOM.equals()` - This tests for equality of all relevant fields, including the SBOM `DependencyTree`.
    - `DependencyTree.equals()` - This is a quick-and-dirty fix to compare two instances of a `DependencyTree` WITHOUT
      regard to UUIDs. This allows us to have two separate SBOMs with the same components (with randomly generated UUIDs)
      and still be equal.
    - `DependencyTree.toString()` & `DependencyTree.dependencyMapToString()`, which were both added to support
      `DependencyTree.equals()`. The `equals()` method simply compares the `toString()` methods of each `DependencyTree`,
      which are generated by the `dependencyMapToString()` method.
        - This is a simple recursive method that uses indentations
          to represent how an individual component is nested, thus removing a reliance on UUIDs.
        - Each component can then be compared by checking its string representation (which is currently just the component name)
- Added "copy" constructor to `ParserComponent` Class to construct an instance from a `Component` instance.
    - Updated `SBOMGenerator` to allow processing SBOMs that contain `Component` instances.

### Changed
- All tests in `SBOMGeneratorTest` now use `Debug.log()` instead of default system I/O.
- Both output methods in `SBOMGenerator` (`writeFile()` & `writeFileToString`) now throw a `GeneratorException` for
  ease of testing.
- `SBOMGeneratorTest.addTestComponentsToSBOM()` is now static to allow re-use in other tests.
- `SBOMGeneratorTest.generatePathToSBOM()` is now public to allow use for filepath generation in tests.
- Translator fixes:
    - Fixed `TranslatorCDXJSON` Class parsing in timestamps in the wrong format.
    - Fixed `TranslatorCDXJSON` & `TranslatorCDXXML` Classes parsing in an incorrect tool string.
    - Fixed `TranslatorSPDX` Class incorrectly parsing an SPDX document namespace UUID.
- `SPDXTagValueWriter` Class now re-uses as many tags as possible from `TranslatorSPDX` Class for accuracy.
- Fixed `SPDXStore` not containing the default `SPDXRef-DOCUMENT DESCRIBES SPDXRef-DOCUMENT` relationship.

### Removed
- Removed file parsing in `SBOMGeneratorTest`. Instead, a sample SBOM is created from scratch.
- Removed default root wrapping property of `ObjectMapper`-based serializers, as it was causing the class name to be the
  top-level object of the generated SBOM.
- Removed `bom:` namespace prefix from generated CycloneDX XML SBOMs, as it was interfering with the corresponding
  translator.
- Removed all old sample SBOMs in `doc/Sample SBOMs`.


## Usage
> For running locally, see **Building Project Locally**

How to run: `<targetPath> <optionalArgs...>`

### Examples:
- Display help prompt: `-h`
- Basic: `MyProject/src`
- Debug: 
  - `MyProject/src -d`
  - `-d MyProject/src`
  - `MyProject/src -d`
- Summary: `MyProject/src -s`
- Debug (Overrides Summary): `MyProject/src -d -s`
#### CycloneDX
- `MyProject/src -d`
  - Outputs a JSON CycloneDX SBOM file with debug mode activated
- `MyProject/src -d -o=CycloneDX -f=JSON`
  - Outputs a JSON CycloneDX SBOM file with debug mode activated
- `MyProject/src -o=CycloneDX -f=XML`
  - Outputs an XML CycloneDX SBOM file without debug mode
#### SPDX
- `MyProject/src -d -o=SPDX`
  - Outputs a JSON SPDX SBOM file with debug mode activated
- `MyProject/src -o=SPDX -f=YAML`
  - Outputs an XML SPDX SBOM file without debug mode

### Required Arguments (Ordered)
- `targetPath`: Path to a target file or root directory to parse.

If these arguments are invalid or missing, a CLI script will run to get the correct input.

### Optional Arguments (Unordered, can even be mixed with Required Arguments)
Use these in any combination or order, nothing will conflict unless otherwise noted.

The driver has several optional boolean flags:
- `-d`: Debug Mode; Enable debug messages to be printed to the stdout
- `-h`: Display command line usages
- `-s`: Summary Mode; Disable ALL messages from tool
> NOTE: Debug mode will override Summary mode (safe conflict)

It also has several optional `'key=value'` flags:
- `-o=specification`: Output specification; Select a supported SBOM specification to output to
    - Supported Formats:
        - `CycloneDX`
        - `SPDX`
> NOTE: Output specification defaults to CycloneDX if not specified

- `-f=format`: Output format; Select a supported format to output to
   - Supported Formats:
      - `json`
      - `xml`
      - `yaml`
> NOTE: Output format defaults to JSON if not specified

> NOTE: If more than one component shares the same `componentName`, the user
> is given a choice between all matches.

## Supported Project File Formats:
This list of formats represents all given files that can be parsed, if the extension is not on this list,
the file will not be parsed.
- `Language Files`
  - `go`
  - `rust`
  - `ruby`
  - `perl`
  - `scala`
  - `java`
  - `js/ts`
  - `python`
  - `c#`
  - `c++`
  - `c`
- `Package Manager Files`
  - `pom.xml`
  - `build.gradle`
  - `.csproj`

## Building Project Locally
This installation is through IntelliJ and builds the project into a JAR through IntelliJ's configuration files.
1. Clone repo
2. `File` > `Project Structure` > `Project`
    - Choose SDK (OpenJDK 19 or similar)
    - `APPLY`
3. `Project Structure` > `Modules` > `Source` > Navigate to `SVIP`
    - Select `core/src/main` and click `Mark as: Sources`.
    - Select `core/src/test` and click `Mark as: Tests`.
    - Select `core/src/test/java/org/svip/sbomfactory/generators/TestData` and click `Mark as: Test Resources`.
    - The `target` folder should already be marked as `Excluded`
    - `APPLY`
4. `Project Structure` > `Modules` > `Dependencies` > `+` > `From Maven` and import the following
    - `com.fasterxml.jackson.svip:jackson-databind:2.13.3`
    - `com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.14.01`
    - `com.google.guava:guava:31.1-jre`
    - `com.googlecode.json-simple:json-simple:1.1.11`
    - `org.junit.jupiter:junit-jupiter:5.9.1`
    - `APPLY`
> NOTE: Once Installed the scope should all be set to `Compile`
5. To configure a build for a JAR artifact:
    1. `File` > `Project Settings` > `Artifacts`
    2. Click the plus sign in the top left and select `JAR` > `From modules with dependencies...`
    3. Set `Module` to `SVIP.core.main`
    4. Set `Main Class` to `SBOMGeneratorCLI (org.svip.sbomfactory.generators`
    5. Select the `copy to the output directory and link via manifest` option under `JAR files from libraries`
6. To build the JAR artifact:
    - `Build` > `Artifacts`
    - The JAR artifact will appear in the default directory specifed (`SVIP\out\artifacts\SVIP_core_main_jar`)

## Structure
The project is structured around an Abstract Parser Core, which handles basic file recursion and other generics. From
the svip, Language-Specific parsers can be created that can handle the details of the language.

![uml](uml.png)
[_Edit the Document Here_](https://drive.google.com/file/d/1RKeNBU7_Qosw1GvXTrkQyCOQ2ea-JcXX/view?usp=share_link)

### Abstract Methods
The following are a list of abstract methods to be implemented by each Language-Specific parser.

    boolean isInternalComponent(Component component);
    boolean isLanguageComponent(Component component);
    Pattern getRegex();
    Component parseRegexMatch(String match);
See the [abstract method](src/main/java/parsers/ParserCore.java) implementation of the ParserCore for more details.

## Creating New Parsers
In order to create a new Parser, follow these steps.
1. Create new Parser class that extends `ParserCore`
2. Add the new language to `SUPPORTED_LANGUAGES` in `Main.java`

   > ```put("language", new parser());```
3. Implement Abstract Methods
> NOTE: For `isLanguageComponent`, the current practice is to use an HTTP request to the official documentation to test
> to see if the package is from the Language maintainers

### Logging
The ParserCore has a number of logging options to use. Options include `INFO`, `DEBUG`, `WARN`, `ERROR`, and `EXCEPTION`.
These are not required but are available for use when creating new Parsers.


## Contributors
- Derek Garcia
- Dylan Mulligan